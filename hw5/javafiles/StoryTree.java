import java.util.zip.DataFormatException;   //this handles exceptions related to files
import java.io.FileNotFoundException;   //this handles exceptions related to files
import java.io.File;    //this is used to read from a file
import java.io.PrintWriter; //this is used to write to a file
/**
 * Write a fully-documented class named StoryTree, which represents the primary data structure for the Zork game. This class should be a 
 * ternary (3-child) tree of StoryTreeNodes, which are structured as a continuous chain of decisions the user may make to reach the end of 
 * the game (any leaf node). 
 * 
 * @author Grace Wang
 * Stony Brook ID: 115083013
 * Recitation: CSE 214.R01
 */
import java.util.Scanner;
public class StoryTree {
    /*A reference to the root StoryTreeNode of this tree. All StoryTree instances should have the same root node with the following attributes:
        position = "root"
        option = "root"
        message = "Hello, welcome to Zork!"
    Even if the StoryTree is empty and contains no StoryTreeNodes, the root variable should always reference an object with these 
    attributes. This is the starting point of the story, and should have a single left child which begins the game and provides 
    the user with the first message. */
    private StoryTreeNode root;
    /*A reference to the currently selected StoryTreeNode in the tree. The cursor should never be null and should select the root node by default.*/
    private StoryTreeNode cursor;
    /*The current state of the game, which indicates whether the game has ended and, if so, what the result of the game is. */
    private GameState state;

    
    //constructor
    /*Default constructor for the StoryTree class.
    Note: you may include custom constructors which take any parameters you like.
     */
    public StoryTree(){
        //create a root that has the requested attributes from above
        root = new StoryTreeNode("root", "root", "Hello, welcome to Zork!");
        //cursor set to root
        cursor = root;
        //question: what should the state be by default?
        //answer: game's not over girly
        state = GameState.GAME_NOT_OVER;
    }

    //static functions
    /**
     * Reads in a text file describing a StoryTree. See sample input for an example.
     * @param fileName
     * Name of the file to read from.
     * @custom.precondition
     * filename is a non-null, non-empty String that points to a file that exists that is readable, and is valid.
     * @return
     * A new StoryTree generated by the passed in text file is returned.
     * @throws IllegalArgumentException
     * filename is empty or null.
     * @throws DataFormatException
     * The file contained data inconsistent with the expected data format (Note: This is a built in exception. Don't make a custom exception.)
     */
    
     //question: doesn't the fileNotFoundException that is part of the File class the IllegalArgumentException we are throwing? bc the FileNotFoundException makes sure that the file is not null
     public static StoryTree readTree(String fileName) throws IllegalArgumentException, DataFormatException, FileNotFoundException {
        if (fileName.isEmpty() || fileName == null || !fileName.contains(".txt"))
        throw new IllegalArgumentException ("Filename is empty or null.");
        //create a story tree object
        StoryTree tree = new StoryTree();
        /*the Scanner constructor expects a File or InputStream object to read data from. */
        File file = new File(fileName);
        try{
            
            //File file = new File("hw5-SampleStory.txt");
            Scanner fileIn = new Scanner (file);    //question: how do I fix this?
            while (fileIn.hasNextLine()){
                String oneLine = fileIn.nextLine();
                //first for each line, parse it in into an array, with 0th index = position, 1st index = option, 2nd index = message
                /*The split() method takes a regular expression as its argument, and the "|" character is a special character in 
                regular expressions that denotes "or". To split a string on a literal "|" character, you need to escape it using 
                backslashes, like this: String[] oneNode = oneLine.split("\\|"); */
                String [] oneNodeString = oneLine.split("\\| ");
                //testing code
                // for (int i = 0; i < oneNodeString.length; i++){
                //     System.out.print(oneNodeString[i] + " ");
                // }

                //System.out.println();
                if (oneNodeString.length != 3){
                    throw new DataFormatException ("The file contained data inconsistent with the expected data format");
                }

                //maybe remove all the spaces before creating the node

                //create story tree node object
                StoryTreeNode oneNode = new StoryTreeNode(oneNodeString[0], oneNodeString[1], oneNodeString[2]);
                
                //then begin parsing position into correct part of tree by using the position
                String position = oneNodeString[0];
                //but how?
                //what I know: 1 represents leftchild, 2 represents middle child, 3 represents right child

                //test: maybe use a while loop?
                //when we check each position, we start at the root node, and traverse, for every single new node
                tree.cursor = tree.root;
                int i = 0;
                while (position.charAt(i+1) != ' '){
                    //but when we reach the last number, that is when we add a new child
                    switch(position.charAt(i)){
                        case('1'):  //if position is at 1, go into left child
                        tree.cursor = tree.cursor.getLeftChild();
                        break;
                        case('2'): //if position is at 2, go into middle child
                        tree.cursor = tree.cursor.getMiddleChild();
                        break;
                        case('3'):  //if position is at 3, go into right child
                        tree.cursor = tree.cursor.getRightChild();
                        break;
                        default: 
                    }
                    i++;
                }
                //when we reach the last element of the position, set the current cursor (which is still the previous cursor) to the position
                //of the corresponding number/child
                switch(position.charAt(i)){
                    case('1'):  //if last position is at 1, set cursor's left child to the new node
                    tree.cursor.setLeftChild(oneNode);
                    break;
                    case('2'): //if last position is at 2, set cursor's middle child to the new node
                    tree.cursor.setMiddleChild(oneNode);
                    break;
                    case('3'):  //if last position is at 3, set cursor's right child to the new node
                    tree.cursor.setRightChild(oneNode);
                    break;
                    default: 
                }
            }
            fileIn.close();
        }
        
        catch(FileNotFoundException e){
            e.getMessage();
        }


        return tree;
    //if the file is empty, then we return a tree with a single root node
    //otherwise, we read in each line to construct the tree

    }

    /**
     * Saves a StoryTree to the indicated file using the specified data format (same as input).
     * @param fileName
     * Name of the file to read from.
     * @param tree
     * A reference to the tree to save to the indicated file.
     * @custom.precondition
     * tree is non-null.
     * filename is a non-null, non-empty String.
     * @throws IllegalArgumentException
     * filename is empty or null. tree is null.
     */
    //question: is this where we write tree to file?
    //answer: yes
    
    /**
     * Data Format
        This assignment requires you to read data from and save data to a text file called zork.txt. The data in this file should follow 
        a very strict format, which will be detailed as follows:

        A line represent a single StoryTreeNode in the tree, using the following format to store it's data:

        "position | option | message"

        The nodes are stored as a pre-order traversal of the full tree.
        Writing Tree to File
        Writing a tree to a file should proceed in a pre-order traversal. This is to ensure that the nodes in the tree can be read back 
        in the same order and successfully inserted into the tree. While performing the pre-order traversal, you should write each node 
        to its own line using the format indicated above.
     */
    public static void saveTree(String fileName, StoryTree tree) throws IllegalArgumentException {
        if (fileName == null || fileName.isEmpty() || tree == null){
            throw new IllegalArgumentException("File name is empty or null or tree is null.");
        }
        try{
            //File file = new File(fileName);
            PrintWriter fileOut = new PrintWriter(fileName);
            tree.resetCursor();

            //BUG/question: my program refuses to enter this recursive method ):
            //answer: I fixed it! (:
            //it had to do with my cursor, which is supposed to start at the position 1 node, not the root node called welcome to zork
            //cursor/root is a lil confusing
            tree.traverseAndSave(fileOut, tree.getCursor());
            //we need to recursively traverse the tree in preorder form
            //as we traverse each tree, for each node when we usually print, we will get it's data and save it in an array
            //we will create a string for each segment of the node's data field (position, option, message)
            //and then use the fileOut.writeLine for the string
            fileOut.close();
        }
        catch(FileNotFoundException e){
            e.getMessage();
        }
    }

    //custom method to traverse in preorder and print:
    public void traverseAndSave(PrintWriter fileOut, StoryTreeNode cursor){
        String oneNode = cursor.getPosition() + " | " + cursor.getOption() + " | " + cursor.getMessage() + "\n";
        fileOut.write(oneNode);
        if (cursor.getLeftChild() != null)
        traverseAndSave(fileOut, cursor.getLeftChild());
        if (cursor.getMiddleChild() != null)
        traverseAndSave(fileOut, cursor.getMiddleChild());
        if (cursor.getRightChild() != null)
        traverseAndSave(fileOut, cursor.getRightChild());

    }

    //getters/setters
    /**
     * Gets the current state of the game (state variable).
     * @custom.precondition
     * state is not null.
     * @return
     * current state
     */
    public GameState getGameState(){
        return state;
    }

    public void setGameState(GameState state){
        this.state = state;
    }

    /**
     * Gets the current position of the cursor. For example, if cursor referred to a StoryTreeNode with position = "1-2-1", this method 
     * returns "1-2-1". Note the cursor must NEVER be null.
     * question: shouldnt the position string for each node be the entire string and not just a single number?
     * //answer: yes
     * @return
     * position
     */
    public String getCursorPosition(){
        return cursor.getPosition();
    }

    /**
     * Gets the current message of the cursor. For example, if cursor referred to a StoryTreeNode with message = "Hello World", this 
     * method returns "Hello World".
     * @return
     * current message of cursor
     */
    public String getCursorMessage(){
        return cursor.getMessage();
    }

    //only return options of that current node, not the node's children nodes
    /**
     * Returns an array of String pairs - {position, option} for each immediate child of the cursor. Do not recurse into those childrens' 
     * children.
     * For example, if the cursor currently references the node with position "1", getOptions() could return the following:
     * { {"1-1", "Wake up."},
     * "1-2", "Hit snooze."},
     * {"1-3", "Turn off alarm"} }
     * In this case, "1-1" would be the first column, "Wake up." would be the second column.
     * @return
     * Returns an array of String pairs - {position, option} for each immediate child of the cursor.
     */
    public String [][] getOptions(){
        StoryTreeNode [] child = new StoryTreeNode[cursor.countChildren()];
        int k = 0;
        //these conditions below keep track of the children of the cursor
        if (cursor.getLeftChild() != null){
            child [k] = cursor.getLeftChild();
            k++;
        }
        if (cursor.getMiddleChild() != null){
            child [k] = cursor.getMiddleChild();
            k++;
        }
        if (cursor.getRightChild() != null){
            child [k] = cursor.getRightChild();
            k++;
        }
        //this 2d array will store each child's position and option. the 
        String [][] options = new String[cursor.countChildren()][2];
        for (int i = 0; i < options.length; i++){
            //0th index stores the position (question: is the position already in preorder traversal form? or do we have to create the string of positions on our own?)
            //answer: they are already in the correct form!
            options[i][0] = child[i].getPosition();
            //1st index stores the option
            options[i][1] = child[i].getOption();
        }
        return options;
       
    }

    /**
     * Sets the message for the current cursor.
     * @param message
     * message for the current cursor.
     */
    public void setCursorMessage(String message){
        cursor.setMessage(message);
    }

    /**
     * Sets the option for the current cursor.
     * @param option
     * option for the current cursor
     */
    public void setCursorOption(String option){
        cursor.setOption(option);
    }

    //custom getters/setters
    public StoryTreeNode getRoot(){
        return root;
    }

    public StoryTreeNode getCursor(){
        return cursor;
    }

    // public void setRoot(StoryTreeNode root){
    //     this.root = root;
    // }

    public void setCursor(StoryTreeNode cursor){
        this.cursor = cursor;
    }

    //methods
    /**
     * //question: which root node?
     * //the root node we will be using in our tree is the one with position "1". the actual root node is the dummy node that will always be there/the same
     * Resets the cursor to the root node.
     * @custom.postcondition
     * Cursor references root node.
     */
    public void resetCursor(){
        if (root.getLeftChild() != null) 
        cursor = root.getLeftChild();
        else
        cursor = root;
    }

    /**
     * Selects the child with the name indicated by position.
     * @param position
     * The position String of the child to node to select.
     * @custom.precondition
     * The child with the indicated position member variable exists as a direct child of the cursor.
     * @custom.postcondition
     * Cursor references node indicated by position.
     * @throws InvalidArgumentException
     * position is empty or null.
     * @throws NodeNotPresentException
     * Node with indicated position variable was not found. Custom exception.
     */
    public void selectChild(String position) throws InvalidArgumentException, NodeNotPresentException {
        if (position.isEmpty() || position == null)
            throw new InvalidArgumentException("Position cannot be empty or null.");
        //node not present exception 
        //we have to traverse the tree to find the position

        //first break down position string so it just includes numbers
        String integerPosition = "";
        int i = 0;
        while (i < position.length()){
            if (Character.isDigit(position.charAt(i)))
            integerPosition += position.charAt(i);
            i++;
        }
        //i have to initialize the temporary node so it starts at the very root since that is where i am starting my search
        StoryTreeNode temp = root;
        if (findChild(integerPosition, temp) == null)
        throw new NodeNotPresentException("Error. No child " + integerPosition.charAt(integerPosition.length()-1) + " for the current node.");
        else{
            cursor = findChild(integerPosition, temp);
            //System.out.println(cursor);
        }


    }

    //recursive method to find the child
    public StoryTreeNode findChild(String position, StoryTreeNode cursor) {
       if (position.isEmpty() || cursor == null){
        return cursor;    

       }
        else{
            char currentPosition = position.charAt(0);
            switch(currentPosition){
                case('1'):  //if position is at 1, go into left child
                cursor = cursor.getLeftChild();
                break;
                case('2'): //if position is at 2, go into middle child
                cursor = cursor.getMiddleChild();
                break;
                case('3'):  //if position is at 3, go into right child
                cursor = cursor.getRightChild();
                break;
                default: return null;
            }
            return findChild(position.substring(1), cursor);
        }
    }

    /**
     * Adds a new child under the current cursor, with given option and message. You MUST compute the position String in this method.
     * @param option
     * The new String to set as the option of the new child.
     * @param message
     * The new String to set as the message of the new child.
     * @custom.postcondition
     * Cursor has new child, with specified message and option.
     * @throws InvalidArgumentException
     * Either String is empty or null.
     * @throws TreeFullException
     * All three child spots are already full.
     */
    
    public void addChild(String option, String message) throws InvalidArgumentException, TreeFullException{
        if (option.isEmpty() || message.isEmpty() || option == null || message == null)
        throw new InvalidArgumentException("Either String is empty or null.");
        if (cursor.getLeftChild() != null && cursor.getMiddleChild() != null && cursor.getRightChild() != null)
        //throw new TreeFullException("All three child spots are already full.");
        throw new TreeFullException("Error");

        //this is for setting the position of the new child
        int child = 0;
        if (cursor.getLeftChild() == null){
            child = 1;
        }
        else if (cursor.getMiddleChild() == null)
        child = 2;
        else child = 3;

        String cursorPosition = cursor.getPosition().substring(0, cursor.getPosition().length() -1);
        //first remove all spaces in the cursorposition
        String newPosition = "";
            int i =0;
            //this removes any spaces in the position string.
            while (i < cursorPosition.length() && !(cursorPosition.charAt(i) == ' ')){
                newPosition += cursorPosition.charAt(i);
                i++;
            }
        String position = newPosition + "-" + child;
        //System.out.println(position);

        StoryTreeNode newNode = new StoryTreeNode(position, option, message);

        switch(child){
            case(1):    //if the child is in the left subtree, set new node as cursor's left child
            cursor.setLeftChild(newNode);
            break;
            case(2):    //if the child is in the middle subtree, set new node as cursor's middle child
            cursor.setMiddleChild(newNode);
            break;
            case(3):    //if the child is in the right subtree, set new node as cursor's right child
            cursor.setRightChild(newNode);
            break;
        }
        System.out.println();
        System.out.println("Child added.");
        System.out.println();
    }

    /**
     * Removes an immediate child under the current cursor. This method implicitly removes the entire sub-tree for which the indicated 
     * child is root.ldren of the cursor.
     * @param position
     * String indicating the position of the child to be removed.
     * @custom.precondition
     * The child with the indicated position member variable exists as a direct child of the cursor.
     * @custom.postcondition
     * The indicated child and it's entire sub-tree have been removed from the tree.
     * @return
     * A reference to the child removed (along with it's attached sub-tree).
     * @throws NodeNotPresentException
     * Node with indicated position variable was not found. Custom exception.
     */
    public StoryTreeNode removeChild(String position) throws NodeNotPresentException{
        //this method finds the node to be deleted and based on where the node is in the tree, it shifts the subtrees
        //if the child doesn't exist, throw new exception
        StoryTreeNode parent = null;
        StoryTreeNode cursor = root;
        //String integerPosition = "";
       // String integerPosition = position.substring(0, position.length()-1);
        
            String newPosition = "";
            int i =0;
            //this removes any spaces in the position string.
            while (i < position.length() && !(position.charAt(i) == ' ')){
                newPosition += position.charAt(i);
                i++;
            }
        // for (int i = 0; i < position.length(); i++){
        //     if (Character.isDigit(position.charAt(i)))
        //     integerPosition += position.charAt(i);
        // }

        //this finds the node to be removed
        //question: how can we do this recursively?
        for (int x = 0; x < newPosition.length(); x++){
            parent = cursor;
            switch(newPosition.charAt(x)){
                case('1'):
                cursor = cursor.getLeftChild();
                break;
                case('2'):
                cursor = cursor.getMiddleChild();
                break;
                case('3'):
                cursor = cursor.getRightChild();
                break;
                default: break;
            }
        }
        //if/when we find the removed node:
        if (cursor == null)
        throw new NodeNotPresentException("Error. No child " + newPosition.charAt(newPosition.length()-1) + " for the current node.");
        //No child 

        //if left child is null, we have to shift middle and right child left
        if (cursor == parent.getLeftChild()){   //this removes the cursor by breaking the link
            //parent.setLeftChild(null);
            parent.setLeftChild(parent.getMiddleChild());
            parent.setMiddleChild(parent.getRightChild());
            //and then set rightchild to null
            parent.setRightChild(null);

            //now we have to change the positions of middle and right child
            //debug change:
            traverseAndChangePosition(parent, newPosition.length(), parent, parent.getRightChild());
            //traverseAndChangePosition(parent, newPosition.length(), parent, parent.getRightChild());

        }
        //if middle child is null, we have to shift right child to middle
        else if (cursor == parent.getMiddleChild()){
            //parent.setMiddleChild(null);
            parent.setMiddleChild(parent.getRightChild());
            //and then set right child to null
            parent.setRightChild(null);

            //now we have to traverse the shifted siblings and change each of their positions by 1.

            //how? we have to use the removed node's last position. so get the integerPosition length, 
            //take each position, take up to the removed node's length position, subtract by 1
            //String initialParentPosition = parent.getPosition();
            //parent.setPosition(parent.getMiddleChild().getPosition());

            //if we removed the middle child, we should not change the left child
            
            //debug change:
            traverseAndChangePosition(parent, newPosition.length(), parent, parent.getLeftChild());

           // traverseAndChangePosition(parent, newPosition.length(), parent, parent.getLeftChild());
           
           
            // parent.setPosition(initialParentPosition);

            //question: wait! but when I traverse, how do i make sure im not changing the subtree left of the removed subtree
            //when traversing?
            //chatGPT answer: You can achieve this by checking which child you are currently traversing and skipping it if it matches the removed node.
            //question: where should i begin traversing? the parent of the removed node, or traverse each of the siblings of the
            //removed nodes
            //chatGPT answer: To make sure that you do not change the position of the parent node while traversing, you can simply 
            //check if the current node is the same as the parent node before attempting to change its position. If the current node 
            //is the same as the parent node, you can skip the position change and move on to its children.
        }
        else if (cursor == parent.getRightChild()){
            parent.setRightChild(null);
            //if right child is null, we don't have to shift anything
        }
        return cursor;
    }

    //when traverseing and changing the position of each sibling and their desendants, I want to start at the parent
    //node, but there are a few things I have to check: (look at parameters below)
    //StoryTreeNode cursor, int removedLength, StoryTreeNode parent, StoryTreeNode removedChild
    //cursor = each position, removedlength = which position to change, parent = starting point of traversal, untouchedChild = subtree we shouldn't touch bc it wasn't affected by the shifting.
    //after coding:
    /* basically, the only time we shift the subtrees right is if we remove the left subtree and middle subtree. 
    the only time we don't touch the left subtree is if the middle subtree is removed. if the left subtree is removed, we don't touch the right subtree
    so we skip it by setting the cursor to the next sibling.
    */
    //this is a recursive method that traverses the tree and changes the position 
    public void traverseAndChangePosition(StoryTreeNode cursor, int removedLength, StoryTreeNode parent, StoryTreeNode untouchedChild){
        //if we reach a leaf, we return
        if (cursor == null)
        return;
       //test: not sure if its right

        // if (cursor.getLeftChild() == null)
        // return;
        //if the cursor is at the parent root node, we traverse the left child bc 
        //we need the statement below because we don't want to traverse and change the parent frist. the cursor
        //is initially set to the parent, so if the cursor is the parent which it always is when it starts, we have to
        //set cursor to the left child
        if (cursor == parent){
            cursor = cursor.getLeftChild();
            if (cursor == null) return;
        }
        

        // //my codegrade changes:
        // if (cursor == parent.getLeftChild())
        // cursor = cursor.getLeftChild();

        //if cursor is in the right child, 
         if (cursor == untouchedChild){
            if (untouchedChild == parent.getLeftChild()){
                cursor = parent.getMiddleChild();
                if (cursor == null) return;
            }

            //else if untouched child is the rightchild
            else return;
        }
            
        
            int i = 0;
            //int count = 0;
            int changedP;
            String oldPosition = cursor.getPosition();
            String newPosition = "";
            //this removes any spaces in the position string.
            while (!(oldPosition.charAt(i) == ' ')){
                newPosition += oldPosition.charAt(i);
                i++;
            }
            //i= 0;
            // while (i < newPosition.length() && count <= removedLength){
            //     if (Character.isDigit(oldPosition.charAt(i)))
            //     count++;
            //     i++;
            // }

            //split the string so we only change the position that was shifted
            String front = newPosition.substring(0, removedLength-1);
            String end = newPosition.substring(removedLength);
            //this is the position we are changing. so we parse this single integer string into an integer, and then
            //decrement it, and then add it back to position, and set the new position.
            String changedPosition = "" + newPosition.charAt(removedLength-1);
            //if (!changedPosition.isEmpty() && !changedPosition.contains(" ")){
                 changedP = Integer.parseInt(changedPosition);
                changedP--;
                String finalNewPosition = front + changedP + end;
                cursor.setPosition(finalNewPosition);
            //}

            //this traverses all the rest of the children and siblings.
            traverseAndChangePosition(cursor.getLeftChild(), removedLength, parent, untouchedChild);
            traverseAndChangePosition(cursor.getMiddleChild(), removedLength, parent, untouchedChild);
            traverseAndChangePosition(cursor.getRightChild(), removedLength, parent, untouchedChild);


       // }


    }
    // public StoryTreeNode removeChildRecursive(String position) throws NodeNotPresentException {
    //     StoryTreeNode parent = root;
    //     StoryTreeNode temp = root.getLeftChild();   //gets the root of the tree
    //     if (temp == null)
    //     throw new NodeNotPresentException("Node with indicated position variable was not found. ");
    //     if (temp.getPosition().equals(position)){
    //         if (parent.getLeftChild() == temp)
    //         parent.setLeftChild(null);
    //         else if (parent.getMiddleChild() == temp)
    //         parent.setMiddleChild(null);
    //         else parent.setRightChild(null);
    //         return temp;
    //     }
    //     else{
            
    //     }
    // }



}
