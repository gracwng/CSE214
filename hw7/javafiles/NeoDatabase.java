/**
 * Write a fully documented class named NeoDatabase which will contain and manage the NearEarthObject records which have been downloaded 
 * from the online dataset. The specific data structure used to implment this database is up to you - any Java API class may be used or 
 * customized for this purpose. While deciding which structure to use, be sure to consider the operations which will be performed on this 
 * database, as well as the pros and cons for using various structures such as LinkedLists, Trees, Hashtables, and the like (keep in mind 
 * that Collections.sort() can only operate on a class which implements the List interface).
 * 
 * I will be using a hashmap. the key will be the unique reference ID, and the value will be its object which contains all its unique 
 * informaiton
 * Actually, I can't use a hashmap because it doesn't implement the list interface which is needed to compare objects. Instead, I will 
 * use an arraylist because
 * since we are sorting, we need fast random access to its elements which will be faster using an arraylist than a linkedlist where we 
 * would have to traverse the entire list
 * 
 * @author Grace Wang
 * Stony Brook ID: 115083013
 * Recitation: CSE 214.R01
 * April 22, 2023
 */

import big.data.DataSource;
import java.util.Collections;
import java.util.Comparator;
import java.util.ArrayList;

public class NeoDatabase {
    /* API Key specific to this application used to perform queries to the NASA NeoW API. You must register for one at this page in order 
    to make queries to the dataset.*/
    public static final String API_KEY = "61DVWgzQ8XNaDEx87H1X2jDVpvMgcxIMfsv2QQd4";
    /*URL of the REST API used to conduct queries. The query parameters will be appended to the end of this string, which will indicate 
    the page number requested by the user along with the program's uniqe API_KEY described above (see buildQueryURL() below for further 
    information). */
    public static final String API_ROOT = "https://api.nasa.gov/neo/rest/v1/neo/browse?";

    private ArrayList <NearEarthObject> dataBase = new ArrayList<>();

    /**
     * Default Constructor.
     * @custom.postConditions
     * The database has been constructed and is empty.
     */
    public NeoDatabase(){
        /*ArrayList<NearEarthObject> dataBase = new ArrayList<>();*/
    }

    /**
     * Builds a query URL given a page number. This should be a simple method which returns (API_ROOT + "page=" + pageNumber + 
     * "&api_key=" + API_KEY)
     * @param pageNumber
     * Integer ranging from 0 to 715 indicating the page the user wishes to load.
     * @custom.precondition
     * 0 ≤ page ≤ 715.
     * @return
     * @throws IllegalArgumentException
     * If pageNumber is not in the valid range.
     */
    public String buildQueryURL(int pageNumber) throws IllegalArgumentException{
        if (pageNumber < 0 || pageNumber > 715)
            throw new IllegalArgumentException("Page number is not in the valid range.");
        return API_ROOT + "page=" + pageNumber + "&api_key=" + API_KEY;
    }

    /**
     * Opens a connection to the data source indicated by queryURL and adds all NearEarthObjects found in the dataset.
     * @param queryURL
     * String containing the URL requesting a dataset from the NASA NeoW service (should be generated by buildQueryURL() above).
     * @custom.precondition
     * queryURL is a non-null string representing a valid API request to the NASA NeoW service.
     * @custom.postcondition
     * All NearEarthObject records returned have been added to the database, or else a IllegalArgumentException has been thrown.
     * @throws IllegalArgumentException
     * If queryURL is null or cound not be resolved by the server.
     */
    public void addAll(String queryURL) throws IllegalArgumentException{
    if (queryURL == null)   //Question: how do I check if queryURL could not be resolved by the server. Answer: put the methods related to bigData into a catch try block.
        //because big data probably has its own ways to handle the exceptions, we just have to also be able to handle them when they happen in our program
        throw new IllegalArgumentException("Query is null or could not be resolved by the server.");
    //the connectJSon method connects a dataSource object to a JSON file. This allows us to extract data from it
    try{
        DataSource ds = DataSource.connectJSON(queryURL);
        //the dataSource class contains a useful method called fetchArray() which automatically constructs instances of a
        // class given the class name as a String and a list of idenfiers to be used in the constructor
        ds.load();
        //constructs and returns an array of myData instances.
        //fetchArray() takes the name of the class as a String as the first parameter, then a list of identifiers
        // showing it where to find the values for th econstructor parameters

    ArrayList<NearEarthObject> data = ds.fetchList(
                "NearEarthObject",
                "near_earth_objects/neo_reference_id",
                "near_earth_objects/name", "near_earth_objects/absolute_magnitude_h",
                "near_earth_objects/estimated_diameter/kilometers/estimated_diameter_min",
                "near_earth_objects/estimated_diameter/kilometers/estimated_diameter_max",
                "near_earth_objects/is_potentially_hazardous_asteroid",
                "near_earth_objects/close_approach_data/epoch_date_close_approach",
                "near_earth_objects/close_approach_data/miss_distance/kilometers",
                "near_earth_objects/close_approach_data/orbiting_body");
//        for (NearEarthObject nearEarthObject : dataBase) {
//            System.out.println(nearEarthObject.toString());
//        }
        dataBase.addAll(data);

    }
    catch(IllegalArgumentException e){
        System.out.println(e);
    }
    catch(NullPointerException e){
        System.out.println(e);
    }

    }

    /**
     * Sorts the database using the specified Comparator of NearEarthObjects.
     * @param comp
     * Comparator of NearEarthObjects which will be used to sort the database. This parameter can be any of the required Comparator 
     * classes listed above.
     * @custom.precondition
     * comp is not null.
     * @custom.postcondition
     * The database has been sorted based on the order specified by the inidcated Comparator of NearEarthObjects.
     * @throws IllegalArgumentException
     * If comp is null.
     * @custom.Note:
     * This method can utilize the Arrays.sort(T[] array, Comparator<T> comp) or Collections.sort(List<T> array, Comparator<T> comp) 
     * functions to sort the database (note that these functions only take an array of objects and a List of objects, repectively).
     */
    public void sort(Comparator<NearEarthObject> comp) throws IllegalArgumentException{
        if (comp == null) throw new IllegalArgumentException("Comparator cannot be null.");

        Collections.sort(dataBase, comp);
//        for (NearEarthObject nearEarthObject : dataBase) {
//            System.out.println(nearEarthObject.toString());
//        }
    }

    /**
     * Displays the database in a neat, tabular form, listing all member variables for each NearEarthObject. Note the table should 
     * be printed in the order specified by the last sort() call.
     * @custom.precondition
     * This NeoDatabase is initialized and not null.
     * @custom.postcondition
     * The table has been printed to the console but remains unchanged.
     */
    public void printTable(){
        System.out.println(" ID   |           Name            | Mag. | Diameter | Danger | Close Date | Miss Dist | Orbits");
        System.out.println("================================================================================================");
        for (NearEarthObject nearEarthObject : dataBase) {
            System.out.println(nearEarthObject.toString());
        }
    }
}


